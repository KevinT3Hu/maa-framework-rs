/* automatically generated by rust-bindgen 0.69.4 */
/* used for building on docs.rs */

pub const MaaTaskParam_Empty: &[u8; 3] = b"{}\0";
pub const MaaAdbControllerType_Touch_Mask: u32 = 255;
pub const MaaAdbControllerType_Key_Mask: u32 = 65280;
pub const MaaAdbControllerType_Screencap_Mask: u32 = 16711680;
pub const MaaWin32ControllerType_Touch_Mask: u32 = 255;
pub const MaaWin32ControllerType_Key_Mask: u32 = 65280;
pub const MaaWin32ControllerType_Screencap_Mask: u32 = 16711680;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaStringBuffer {
    _unused: [u8; 0],
}
pub type MaaStringBufferHandle = *mut MaaStringBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaImageBuffer {
    _unused: [u8; 0],
}
pub type MaaImageBufferHandle = *mut MaaImageBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaResourceAPI {
    _unused: [u8; 0],
}
pub type MaaResourceHandle = *mut MaaResourceAPI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaControllerAPI {
    _unused: [u8; 0],
}
pub type MaaControllerHandle = *mut MaaControllerAPI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaInstanceAPI {
    _unused: [u8; 0],
}
pub type MaaInstanceHandle = *mut MaaInstanceAPI;
pub type MaaBool = u8;
pub type MaaSize = u64;
pub type MaaStringView = *const ::std::os::raw::c_char;
pub type MaaStatus = i32;
pub const MaaStatusEnum_MaaStatus_Invalid: MaaStatusEnum = 0;
pub const MaaStatusEnum_MaaStatus_Pending: MaaStatusEnum = 1000;
pub const MaaStatusEnum_MaaStatus_Running: MaaStatusEnum = 2000;
pub const MaaStatusEnum_MaaStatus_Success: MaaStatusEnum = 3000;
pub const MaaStatusEnum_MaaStatus_Failed: MaaStatusEnum = 4000;
pub type MaaStatusEnum = ::std::os::raw::c_int;
pub type MaaLoggingLevel = i32;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Off: MaaLoggingLevelEunm = 0;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Fatal: MaaLoggingLevelEunm = 1;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Error: MaaLoggingLevelEunm = 2;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Warn: MaaLoggingLevelEunm = 3;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Info: MaaLoggingLevelEunm = 4;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Debug: MaaLoggingLevelEunm = 5;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_Trace: MaaLoggingLevelEunm = 6;
pub const MaaLoggingLevelEunm_MaaLoggingLevel_All: MaaLoggingLevelEunm = 7;
pub type MaaLoggingLevelEunm = ::std::os::raw::c_int;
pub type MaaId = i64;
pub type MaaCtrlId = MaaId;
pub type MaaResId = MaaId;
pub type MaaTaskId = MaaId;
pub type MaaOption = i32;
pub type MaaOptionValue = *mut ::std::os::raw::c_void;
pub type MaaOptionValueSize = u64;
pub type MaaGlobalOption = MaaOption;
pub const MaaGlobalOptionEnum_MaaGlobalOption_Invalid: MaaGlobalOptionEnum = 0;
#[doc = " Log dir\n\n value: string, eg: \"C:\\\\Users\\\\Administrator\\\\Desktop\\\\log\"; val_size: string length"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_LogDir: MaaGlobalOptionEnum = 1;
#[doc = " Whether to save draw\n\n value: bool, eg: true; val_size: sizeof(bool)"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_SaveDraw: MaaGlobalOptionEnum = 2;
#[doc = " Dump all screenshots and actions\n\n Recording will evaluate to true if any of this or MaaCtrlOptionEnum::MaaCtrlOption_Recording\n is true. value: bool, eg: true; val_size: sizeof(bool)"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_Recording: MaaGlobalOptionEnum = 3;
#[doc = " The level of log output to stdout\n\n value: MaaLoggingLevel, val_size: sizeof(MaaLoggingLevel)\n default value is MaaLoggingLevel_Error"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_StdoutLevel: MaaGlobalOptionEnum = 4;
#[doc = " Whether to show hit draw\n\n value: bool, eg: true; val_size: sizeof(bool)"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_ShowHitDraw: MaaGlobalOptionEnum = 5;
#[doc = " Whether to callback debug message\n\n value: bool, eg: true; val_size: sizeof(bool)"]
pub const MaaGlobalOptionEnum_MaaGlobalOption_DebugMessage: MaaGlobalOptionEnum = 6;
pub type MaaGlobalOptionEnum = ::std::os::raw::c_int;
pub type MaaResOption = MaaOption;
pub const MaaResOptionEnum_MaaResOption_Invalid: MaaResOptionEnum = 0;
pub type MaaResOptionEnum = ::std::os::raw::c_int;
pub type MaaCtrlOption = MaaOption;
pub const MaaCtrlOptionEnum_MaaCtrlOption_Invalid: MaaCtrlOptionEnum = 0;
#[doc = " Only one of long and short side can be set, and the other is automatically scaled according\n to the aspect ratio.\n\n value: int, eg: 1920; val_size: sizeof(int)"]
pub const MaaCtrlOptionEnum_MaaCtrlOption_ScreenshotTargetLongSide: MaaCtrlOptionEnum = 1;
#[doc = " Only one of long and short side can be set, and the other is automatically scaled according\n to the aspect ratio.\n\n value: int, eg: 1080; val_size: sizeof(int)"]
pub const MaaCtrlOptionEnum_MaaCtrlOption_ScreenshotTargetShortSide: MaaCtrlOptionEnum = 2;
#[doc = " For StartApp\n\n value: string, eg: \"com.hypergryph.arknights/com.u8.sdk.U8UnityContext\"; val_size: string\n length"]
pub const MaaCtrlOptionEnum_MaaCtrlOption_DefaultAppPackageEntry: MaaCtrlOptionEnum = 3;
#[doc = " For StopApp\n\n value: string, eg: \"com.hypergryph.arknights\"; val_size: string length"]
pub const MaaCtrlOptionEnum_MaaCtrlOption_DefaultAppPackage: MaaCtrlOptionEnum = 4;
#[doc = " Dump all screenshots and actions\n\n Recording will evaluate to true if any of this or\n MaaGlobalOptionEnum::MaaGlobalOption_Recording is true.\n\n value: bool, eg: true; val_size: sizeof(bool)"]
pub const MaaCtrlOptionEnum_MaaCtrlOption_Recording: MaaCtrlOptionEnum = 5;
#[doc = " @brief Option keys for controller instance options. See MaaControllerSetOption().\n"]
pub type MaaCtrlOptionEnum = ::std::os::raw::c_int;
pub type MaaInstOption = MaaOption;
pub const MaaInstOptionEnum_MaaInstOption_Invalid: MaaInstOptionEnum = 0;
pub type MaaInstOptionEnum = ::std::os::raw::c_int;
pub type MaaAdbControllerType = i32;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Invalid: MaaAdbControllerTypeEnum = 0;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Touch_Adb: MaaAdbControllerTypeEnum = 1;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Touch_MiniTouch: MaaAdbControllerTypeEnum =
    2;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Touch_MaaTouch: MaaAdbControllerTypeEnum =
    3;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Touch_AutoDetect: MaaAdbControllerTypeEnum =
    254;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Key_Adb: MaaAdbControllerTypeEnum = 256;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Key_MaaTouch: MaaAdbControllerTypeEnum =
    512;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Key_AutoDetect: MaaAdbControllerTypeEnum =
    65024;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Input_Preset_Adb: MaaAdbControllerTypeEnum =
    257;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Input_Preset_Minitouch:
    MaaAdbControllerTypeEnum = 258;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Input_Preset_Maatouch:
    MaaAdbControllerTypeEnum = 515;
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Input_Preset_AutoDetect:
    MaaAdbControllerTypeEnum = 65278;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_FastestWay_Compatible:
    MaaAdbControllerTypeEnum = 65536;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_RawByNetcat:
    MaaAdbControllerTypeEnum = 131072;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_RawWithGzip:
    MaaAdbControllerTypeEnum = 196608;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_Encode: MaaAdbControllerTypeEnum =
    262144;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_EncodeToFile:
    MaaAdbControllerTypeEnum = 327680;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_MinicapDirect:
    MaaAdbControllerTypeEnum = 393216;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_MinicapStream:
    MaaAdbControllerTypeEnum = 458752;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_FastestLosslessWay:
    MaaAdbControllerTypeEnum = 16580608;
#[doc = " \\deprecated"]
pub const MaaAdbControllerTypeEnum_MaaAdbControllerType_Screencap_FastestWay:
    MaaAdbControllerTypeEnum = 16646144;
#[doc = " @brief ADB controller type\n\n The ADB controller type consists of three parts: touch, key, and screencap.\n The touch part is used to control the touch events on the device.\n The key part is used to control the key events on the device.\n The screencap part is used to capture the screen of the device.\n The final value is the combination of the three parts as follows:\n\n touch_type | key_type | screencap_type\n"]
pub type MaaAdbControllerTypeEnum = ::std::os::raw::c_int;
pub type MaaDbgControllerType = i32;
pub const MaaDbgControllerTypeEnum_MaaDbgController_Invalid: MaaDbgControllerTypeEnum = 0;
pub const MaaDbgControllerTypeEnum_MaaDbgControllerType_CarouselImage: MaaDbgControllerTypeEnum = 1;
pub const MaaDbgControllerTypeEnum_MaaDbgControllerType_ReplayRecording: MaaDbgControllerTypeEnum =
    2;
pub type MaaDbgControllerTypeEnum = ::std::os::raw::c_int;
pub type MaaThriftControllerType = i32;
pub const MaaThriftControllerTypeEnum_MaaThriftController_Invalid: MaaThriftControllerTypeEnum = 0;
pub const MaaThriftControllerTypeEnum_MaaThriftControllerType_Socket: MaaThriftControllerTypeEnum =
    1;
pub const MaaThriftControllerTypeEnum_MaaThriftControllerType_UnixDomainSocket:
    MaaThriftControllerTypeEnum = 2;
pub type MaaThriftControllerTypeEnum = ::std::os::raw::c_int;
pub type MaaWin32ControllerType = i32;
pub const MaaWin32ControllerTypeEnum_MaaWin32Controller_Invalid: MaaWin32ControllerTypeEnum = 0;
pub const MaaWin32ControllerTypeEnum_MaaWin32ControllerType_Touch_SendMessage:
    MaaWin32ControllerTypeEnum = 1;
pub const MaaWin32ControllerTypeEnum_MaaWin32ControllerType_Key_SendMessage:
    MaaWin32ControllerTypeEnum = 256;
pub const MaaWin32ControllerTypeEnum_MaaWin32ControllerType_Screencap_GDI:
    MaaWin32ControllerTypeEnum = 65536;
pub const MaaWin32ControllerTypeEnum_MaaWin32ControllerType_Screencap_DXGI_DesktopDup:
    MaaWin32ControllerTypeEnum = 131072;
pub const MaaWin32ControllerTypeEnum_MaaWin32ControllerType_Screencap_DXGI_FramePool:
    MaaWin32ControllerTypeEnum = 262144;
#[doc = " @brief Win32 controller type\n\n See AdbControllerTypeEnum to know how the value is composed.\n"]
pub type MaaWin32ControllerTypeEnum = ::std::os::raw::c_int;
pub type MaaWin32Hwnd = *mut ::std::os::raw::c_void;
pub type MaaTransparentArg = *mut ::std::os::raw::c_void;
pub type MaaCallbackTransparentArg = MaaTransparentArg;
#[doc = " @brief The callback function type.\n\n @param msg The message. See MaaMsg.h\n @param details_json The details in JSON format. See doc in MaaMsg.h"]
pub type MaaAPICallback = ::std::option::Option<
    unsafe extern "C" fn(
        msg: MaaStringView,
        details_json: MaaStringView,
        callback_arg: MaaTransparentArg,
    ),
>;
pub type MaaResourceCallback = MaaAPICallback;
pub type MaaControllerCallback = MaaAPICallback;
pub type MaaInstanceCallback = MaaAPICallback;
pub type MaaCustomControllerHandle = *mut MaaCustomControllerAPI;
pub type MaaCustomRecognizerHandle = *mut MaaCustomRecognizerAPI;
pub type MaaCustomActionHandle = *mut MaaCustomActionAPI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaSyncContextAPI {
    _unused: [u8; 0],
}
pub type MaaSyncContextHandle = *mut MaaSyncContextAPI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaRect {
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
}
#[test]
fn bindgen_test_layout_MaaRect() {
    const UNINIT: ::std::mem::MaybeUninit<MaaRect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MaaRect>(),
        16usize,
        concat!("Size of: ", stringify!(MaaRect))
    );
    assert_eq!(
        ::std::mem::align_of::<MaaRect>(),
        4usize,
        concat!("Alignment of ", stringify!(MaaRect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaRect),
            "::",
            stringify!(height)
        )
    );
}
pub type MaaRectHandle = *mut MaaRect;
extern "C" {
    #[doc = " \\deprecated Use MaaAdbControllerCreateV2() instead."]
    pub fn MaaAdbControllerCreate(
        adb_path: MaaStringView,
        address: MaaStringView,
        type_: MaaAdbControllerType,
        config: MaaStringView,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    #[doc = " @brief Create a win32 controller instance.\n\n @param hWnd The win32 window handle to control. This can be retrieved by helpers provided in\n MaaToolkitWin32Window.h.\n @param type The type of the win32 controller. See #MaaWin32ControllerTypeEnum.\n @param callback The callback function. See ::MaaAPICallback.\n @param callback_arg The callback arg that will be passed to the callback function.\n @return MaaControllerHandle The handle of the created controller instance."]
    pub fn MaaWin32ControllerCreate(
        hWnd: MaaWin32Hwnd,
        type_: MaaWin32ControllerType,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    #[doc = " @brief Create a ADB controller instance.\n\n @param adb_path The path of ADB executable.\n @param address The ADB serial of the target device.\n @param type The type of the ADB controller. See #MaaAdbControllerTypeEnum.\n @param config The config of the ADB controller.\n @param agent_path The path of the agent executable.\n @param callback The callback function. See ::MaaAPICallback.\n @param callback_arg The callback arg that will be passed to the callback function.\n @return MaaControllerHandle The handle of the created controller instance."]
    pub fn MaaAdbControllerCreateV2(
        adb_path: MaaStringView,
        address: MaaStringView,
        type_: MaaAdbControllerType,
        config: MaaStringView,
        agent_path: MaaStringView,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    #[doc = " @brief Create a custom controller instance.\n\n @param handle The handle to your instance of custom controller. See MaaCustomControllerAPI.\n @param handle_arg The arg that will be passed to the custom controller API.\n @param callback The callback function. See ::MaaAPICallback.\n @param callback_arg The callback arg that will be passed to the callback function.\n @return MaaControllerHandle The handle of the created controller instance."]
    pub fn MaaCustomControllerCreate(
        handle: MaaCustomControllerHandle,
        handle_arg: MaaTransparentArg,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    pub fn MaaThriftControllerCreate(
        type_: MaaThriftControllerType,
        host: MaaStringView,
        port: i32,
        config: MaaStringView,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    pub fn MaaDbgControllerCreate(
        read_path: MaaStringView,
        write_path: MaaStringView,
        type_: MaaDbgControllerType,
        config: MaaStringView,
        callback: MaaControllerCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaControllerHandle;
}
extern "C" {
    #[doc = " @brief Free the controller instance.\n\n @param ctrl"]
    pub fn MaaControllerDestroy(ctrl: MaaControllerHandle);
}
extern "C" {
    #[doc = " @brief Set options for a given controller instance.\n\n This function requires a given set of option keys and value types, otherwise this will fail.\n See #MaaCtrlOptionEnum for details.\n\n @param ctrl The handle of the controller instance to set options for.\n @param key The option key.\n @param value The option value.\n @param val_size The size of the option value.\n @return MaaBool Whether the option is set successfully."]
    pub fn MaaControllerSetOption(
        ctrl: MaaControllerHandle,
        key: MaaCtrlOption,
        value: MaaOptionValue,
        val_size: MaaOptionValueSize,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @defgroup MaaControllerPostRequest Controller Requests\n\n The following functions post their corresponding requests to the controller and return the id\n of the request.\n @{"]
    pub fn MaaControllerPostConnection(ctrl: MaaControllerHandle) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostClick(ctrl: MaaControllerHandle, x: i32, y: i32) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostSwipe(
        ctrl: MaaControllerHandle,
        x1: i32,
        y1: i32,
        x2: i32,
        y2: i32,
        duration: i32,
    ) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostPressKey(ctrl: MaaControllerHandle, keycode: i32) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostInputText(ctrl: MaaControllerHandle, text: MaaStringView) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostTouchDown(
        ctrl: MaaControllerHandle,
        contact: i32,
        x: i32,
        y: i32,
        pressure: i32,
    ) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostTouchMove(
        ctrl: MaaControllerHandle,
        contact: i32,
        x: i32,
        y: i32,
        pressure: i32,
    ) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostTouchUp(ctrl: MaaControllerHandle, contact: i32) -> MaaCtrlId;
}
extern "C" {
    pub fn MaaControllerPostScreencap(ctrl: MaaControllerHandle) -> MaaCtrlId;
}
extern "C" {
    #[doc = " @brief Get the status of a request identified by the given id.\n\n @param ctrl\n @param id\n @return MaaStatus The status of the request."]
    pub fn MaaControllerStatus(ctrl: MaaControllerHandle, id: MaaCtrlId) -> MaaStatus;
}
extern "C" {
    #[doc = " @brief Wait for the request identified by the given id to complete.\n\n @param ctrl\n @param id\n @return MaaStatus The status of the request."]
    pub fn MaaControllerWait(ctrl: MaaControllerHandle, id: MaaCtrlId) -> MaaStatus;
}
extern "C" {
    #[doc = " @brief Check if the controller is connected.\n\n @param ctrl\n @return MaaBool"]
    pub fn MaaControllerConnected(ctrl: MaaControllerHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the image buffer of the last screencap request.\n\n @param ctrl\n @param[out] buffer The buffer that the image data will be stored in.\n\n @return MaaBool Whether the image buffer is retrieved successfully."]
    pub fn MaaControllerGetImage(
        ctrl: MaaControllerHandle,
        buffer: MaaImageBufferHandle,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the UUID of the controller.\n\n @param ctrl\n @param[out] buffer The buffer that the UUID will be stored in.\n\n @return MaaBool Whether the resolution is retrieved successfully."]
    pub fn MaaControllerGetUUID(
        ctrl: MaaControllerHandle,
        buffer: MaaStringBufferHandle,
    ) -> MaaBool;
}
#[doc = " @brief The custom controller API.\n\n To create a custom controller, you need to implement this API.\n\n You do not have to implement all the functions in this API. Instead, just implement the\n functions you need. Do note that if an unimplemented function is called, the framework will\n likely crash."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaCustomControllerAPI {
    pub connect:
        ::std::option::Option<unsafe extern "C" fn(handle_arg: MaaTransparentArg) -> MaaBool>,
    #[doc = " Write result to buffer."]
    pub request_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            handle_arg: MaaTransparentArg,
            buffer: MaaStringBufferHandle,
        ) -> MaaBool,
    >,
    #[doc = " Write result to width and height."]
    pub request_resolution: ::std::option::Option<
        unsafe extern "C" fn(
            handle_arg: MaaTransparentArg,
            width: *mut i32,
            height: *mut i32,
        ) -> MaaBool,
    >,
    pub start_app: ::std::option::Option<
        unsafe extern "C" fn(intent: MaaStringView, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
    pub stop_app: ::std::option::Option<
        unsafe extern "C" fn(intent: MaaStringView, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
    #[doc = " Write result to buffer."]
    pub screencap: ::std::option::Option<
        unsafe extern "C" fn(
            handle_arg: MaaTransparentArg,
            buffer: MaaImageBufferHandle,
        ) -> MaaBool,
    >,
    pub click: ::std::option::Option<
        unsafe extern "C" fn(x: i32, y: i32, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
    pub swipe: ::std::option::Option<
        unsafe extern "C" fn(
            x1: i32,
            y1: i32,
            x2: i32,
            y2: i32,
            duration: i32,
            handle_arg: MaaTransparentArg,
        ) -> MaaBool,
    >,
    pub touch_down: ::std::option::Option<
        unsafe extern "C" fn(
            contact: i32,
            x: i32,
            y: i32,
            pressure: i32,
            handle_arg: MaaTransparentArg,
        ) -> MaaBool,
    >,
    pub touch_move: ::std::option::Option<
        unsafe extern "C" fn(
            contact: i32,
            x: i32,
            y: i32,
            pressure: i32,
            handle_arg: MaaTransparentArg,
        ) -> MaaBool,
    >,
    pub touch_up: ::std::option::Option<
        unsafe extern "C" fn(contact: i32, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
    pub press_key: ::std::option::Option<
        unsafe extern "C" fn(keycode: i32, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
    pub input_text: ::std::option::Option<
        unsafe extern "C" fn(text: MaaStringView, handle_arg: MaaTransparentArg) -> MaaBool,
    >,
}
#[test]
fn bindgen_test_layout_MaaCustomControllerAPI() {
    const UNINIT: ::std::mem::MaybeUninit<MaaCustomControllerAPI> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MaaCustomControllerAPI>(),
        104usize,
        concat!("Size of: ", stringify!(MaaCustomControllerAPI))
    );
    assert_eq!(
        ::std::mem::align_of::<MaaCustomControllerAPI>(),
        8usize,
        concat!("Alignment of ", stringify!(MaaCustomControllerAPI))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_uuid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(request_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_resolution) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(request_resolution)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_app) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(start_app)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_app) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(stop_app)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screencap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(screencap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).click) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(click)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swipe) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(swipe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touch_down) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(touch_down)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touch_move) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(touch_move)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).touch_up) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(touch_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).press_key) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(press_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_text) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomControllerAPI),
            "::",
            stringify!(input_text)
        )
    );
}
extern "C" {
    #[doc = " @brief Create an instance.\n\n @param callback The callback function. See MaaAPICallback\n @param callback_arg The callback arg that will be passed to the callback function.\n @return MaaInstanceHandle"]
    pub fn MaaCreate(
        callback: MaaInstanceCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaInstanceHandle;
}
extern "C" {
    #[doc = " @brief Free the instance.\n\n @param inst"]
    pub fn MaaDestroy(inst: MaaInstanceHandle);
}
extern "C" {
    #[doc = " @brief Set options for a given instance.\n\n This function requires a given set of option keys and value types, otherwise this will fail.\n See #MaaInstOptionEnum for details.\n\n @param inst The handle of the instance to set options for.\n @param key The option key.\n @param value The option value.\n @param val_size The size of the option value.\n @return MaaBool Whether the option is set successfully."]
    pub fn MaaSetOption(
        inst: MaaInstanceHandle,
        key: MaaInstOption,
        value: MaaOptionValue,
        val_size: MaaOptionValueSize,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Bind the instance to an initialized resource.\n\n See functions in MaaResource.h about how to create a resource.\n\n @param inst\n @param res\n @return MaaBool"]
    pub fn MaaBindResource(inst: MaaInstanceHandle, res: MaaResourceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Bind the instance to an initialized controller.\n\n See functions in MaaController.h about how to create a controller.\n\n @param inst\n @param ctrl\n @return MaaBool"]
    pub fn MaaBindController(inst: MaaInstanceHandle, ctrl: MaaControllerHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Check if the instance is initialized.\n\n @param inst\n @return MaaBool"]
    pub fn MaaInited(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Register a custom recognizer to the instance.\n\n See MaaCustomRecognizer.h for details about how to create a custom recognizer.\n\n @param inst\n @param name The name of the recognizer that will be used to reference it.\n @param recognizer\n @param recognizer_arg\n @return MaaBool"]
    pub fn MaaRegisterCustomRecognizer(
        inst: MaaInstanceHandle,
        name: MaaStringView,
        recognizer: MaaCustomRecognizerHandle,
        recognizer_arg: MaaTransparentArg,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Unregister a custom recognizer from the instance.\n\n @param inst\n @param name The name of the recognizer when it was registered.\n @return MaaBool"]
    pub fn MaaUnregisterCustomRecognizer(inst: MaaInstanceHandle, name: MaaStringView) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Clear all custom recognizers registered to the instance.\n\n @param inst\n @return MaaBool"]
    pub fn MaaClearCustomRecognizer(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Register a custom action to the instance.\n\n See MaaCustomAction.h for details about how to create a custom action.\n\n @param inst\n @param name The name of the action that will be used to reference it.\n @param action\n @param action_arg\n @return MaaBool"]
    pub fn MaaRegisterCustomAction(
        inst: MaaInstanceHandle,
        name: MaaStringView,
        action: MaaCustomActionHandle,
        action_arg: MaaTransparentArg,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Unregister a custom action from the instance.\n\n @param inst\n @param name The name of the action when it was registered.\n @return MaaBool"]
    pub fn MaaUnregisterCustomAction(inst: MaaInstanceHandle, name: MaaStringView) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Clear all custom actions registered to the instance.\n\n @param inst\n @return MaaBool"]
    pub fn MaaClearCustomAction(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Post a task to the instance.\n\n The entry should be a task specified in the instance's resources.\n The param takes the same form as the pipeline json and will override the set parameters in\n the json file.\n\n @param inst\n @param entry The entry of the task.\n @param param The parameter of the task.\n @return MaaTaskId The id of the task."]
    pub fn MaaPostTask(
        inst: MaaInstanceHandle,
        entry: MaaStringView,
        param: MaaStringView,
    ) -> MaaTaskId;
}
extern "C" {
    #[doc = " @brief Set the parameter of a task.\n\n See MaaPostTask() for details about the parameter.\n\n @param inst\n @param id The id of the task.\n @param param The parameter of the task.\n @return MaaBool"]
    pub fn MaaSetTaskParam(inst: MaaInstanceHandle, id: MaaTaskId, param: MaaStringView)
        -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the status of a task identified by the id.\n\n @param inst\n @param id\n @return MaaStatus"]
    pub fn MaaTaskStatus(inst: MaaInstanceHandle, id: MaaTaskId) -> MaaStatus;
}
extern "C" {
    #[doc = " @brief Wait for a task to finish.\n\n @param inst\n @param id\n @return MaaStatus"]
    pub fn MaaWaitTask(inst: MaaInstanceHandle, id: MaaTaskId) -> MaaStatus;
}
extern "C" {
    #[doc = " \\deprecated Use !MaaRunning() instead."]
    pub fn MaaTaskAllFinished(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Is maa running?\n\n @param inst\n @return MaaBool"]
    pub fn MaaRunning(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Post a stop signal to the instance.\n\n This immediately stops the instance and all its tasks.\n\n @param inst\n @return MaaBool"]
    pub fn MaaPostStop(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " \\deprecated Use MaaPostStop() instead."]
    pub fn MaaStop(inst: MaaInstanceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the resource handle of the instance.\n\n @param inst\n @return MaaResourceHandle"]
    pub fn MaaGetResource(inst: MaaInstanceHandle) -> MaaResourceHandle;
}
extern "C" {
    #[doc = " @brief Get the controller handle of the instance.\n\n @param inst\n @return MaaControllerHandle"]
    pub fn MaaGetController(inst: MaaInstanceHandle) -> MaaControllerHandle;
}
extern "C" {
    #[doc = " @brief Create a resource.\n\n @param callback The callback function. See MaaAPICallback\n @param callback_arg\n @return MaaResourceHandle"]
    pub fn MaaResourceCreate(
        callback: MaaResourceCallback,
        callback_arg: MaaCallbackTransparentArg,
    ) -> MaaResourceHandle;
}
extern "C" {
    #[doc = " @brief Free the resource.\n\n @param res"]
    pub fn MaaResourceDestroy(res: MaaResourceHandle);
}
extern "C" {
    #[doc = " @brief Add a path to the resource loading paths\n\n @param res\n @param path\n @return MaaResId The id of the resource"]
    pub fn MaaResourcePostPath(res: MaaResourceHandle, path: MaaStringView) -> MaaResId;
}
extern "C" {
    #[doc = " @brief Clear the resource loading paths\n\n @param res\n @return MaaBool Whether the resource is cleared successfully."]
    pub fn MaaResourceClear(res: MaaResourceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the loading status of a resource identified by id.\n\n @param res\n @param id\n @return MaaStatus"]
    pub fn MaaResourceStatus(res: MaaResourceHandle, id: MaaResId) -> MaaStatus;
}
extern "C" {
    #[doc = " @brief Wait for a resource to be loaded.\n\n @param res\n @param id\n @return MaaStatus"]
    pub fn MaaResourceWait(res: MaaResourceHandle, id: MaaResId) -> MaaStatus;
}
extern "C" {
    #[doc = " @brief Check if resources are loaded.\n\n @param res\n @return MaaBool"]
    pub fn MaaResourceLoaded(res: MaaResourceHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Set options for a given resource.\n\n This function requires a given set of option keys and value types, otherwise this will fail.\n See #MaaResOptionEnum for details.\n\n @param res The handle of the resource to set options for.\n @param key The option key.\n @param value The option value.\n @param val_size The size of the option value.\n @return MaaBool Whether the option is set successfully."]
    pub fn MaaResourceSetOption(
        res: MaaResourceHandle,
        key: MaaResOption,
        value: MaaOptionValue,
        val_size: MaaOptionValueSize,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the hash of the resource.\n\n @param res\n @param[out] buffer The buffer where the hash will be written to.\n\n @return MaaBool"]
    pub fn MaaResourceGetHash(res: MaaResourceHandle, buffer: MaaStringBufferHandle) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the task list of the resource.\n\n @param res\n @param[out] buffer The buffer where the task list will be written to.\n\n @return MaaBool"]
    pub fn MaaResourceGetTaskList(res: MaaResourceHandle, buffer: MaaStringBufferHandle)
        -> MaaBool;
}
#[doc = " @brief The custom action API.\n\n To create a custom action, you need to implement this API.\n\n You do not have to implement all the functions in this API. Instead, just implement the\n functions you need. Do note that if an unimplemented function is called, the framework will\n likely crash."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaCustomActionAPI {
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            sync_context: MaaSyncContextHandle,
            task_name: MaaStringView,
            custom_action_param: MaaStringView,
            cur_box: MaaRectHandle,
            cur_rec_detail: MaaStringView,
            action_arg: MaaTransparentArg,
        ) -> MaaBool,
    >,
    pub stop: ::std::option::Option<unsafe extern "C" fn(action_arg: MaaTransparentArg)>,
}
#[test]
fn bindgen_test_layout_MaaCustomActionAPI() {
    const UNINIT: ::std::mem::MaybeUninit<MaaCustomActionAPI> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MaaCustomActionAPI>(),
        16usize,
        concat!("Size of: ", stringify!(MaaCustomActionAPI))
    );
    assert_eq!(
        ::std::mem::align_of::<MaaCustomActionAPI>(),
        8usize,
        concat!("Alignment of ", stringify!(MaaCustomActionAPI))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomActionAPI),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomActionAPI),
            "::",
            stringify!(stop)
        )
    );
}
#[doc = " @brief The custom recognizer API.\n\n To create a custom recognizer, you need to implement this API.\n\n You do not have to implement all the functions in this API. Instead, just implement the\n functions you need. Do note that if an unimplemented function is called, the framework will\n likely crash."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaaCustomRecognizerAPI {
    #[doc = " Write the recognition result to the out_box and return true if the recognition is\n successful. If the recognition fails, return false. You can also write details to the\n out_detail buffer."]
    pub analyze: ::std::option::Option<
        unsafe extern "C" fn(
            sync_context: MaaSyncContextHandle,
            image: MaaImageBufferHandle,
            task_name: MaaStringView,
            custom_recognition_param: MaaStringView,
            recognizer_arg: MaaTransparentArg,
            out_box: MaaRectHandle,
            out_detail: MaaStringBufferHandle,
        ) -> MaaBool,
    >,
}
#[test]
fn bindgen_test_layout_MaaCustomRecognizerAPI() {
    const UNINIT: ::std::mem::MaybeUninit<MaaCustomRecognizerAPI> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MaaCustomRecognizerAPI>(),
        8usize,
        concat!("Size of: ", stringify!(MaaCustomRecognizerAPI))
    );
    assert_eq!(
        ::std::mem::align_of::<MaaCustomRecognizerAPI>(),
        8usize,
        concat!("Alignment of ", stringify!(MaaCustomRecognizerAPI))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analyze) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MaaCustomRecognizerAPI),
            "::",
            stringify!(analyze)
        )
    );
}
extern "C" {
    pub fn MaaSyncContextRunTask(
        sync_context: MaaSyncContextHandle,
        task_name: MaaStringView,
        param: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextRunRecognizer(
        sync_context: MaaSyncContextHandle,
        image: MaaImageBufferHandle,
        task_name: MaaStringView,
        task_param: MaaStringView,
        out_box: MaaRectHandle,
        out_detail: MaaStringBufferHandle,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextRunAction(
        sync_context: MaaSyncContextHandle,
        task_name: MaaStringView,
        task_param: MaaStringView,
        cur_box: MaaRectHandle,
        cur_rec_detail: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextClick(sync_context: MaaSyncContextHandle, x: i32, y: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextSwipe(
        sync_context: MaaSyncContextHandle,
        x1: i32,
        y1: i32,
        x2: i32,
        y2: i32,
        duration: i32,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextPressKey(sync_context: MaaSyncContextHandle, keycode: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextInputText(
        sync_context: MaaSyncContextHandle,
        text: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextTouchDown(
        sync_context: MaaSyncContextHandle,
        contact: i32,
        x: i32,
        y: i32,
        pressure: i32,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextTouchMove(
        sync_context: MaaSyncContextHandle,
        contact: i32,
        x: i32,
        y: i32,
        pressure: i32,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextTouchUp(sync_context: MaaSyncContextHandle, contact: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextScreencap(
        sync_context: MaaSyncContextHandle,
        out_image: MaaImageBufferHandle,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaSyncContextGetTaskResult(
        sync_context: MaaSyncContextHandle,
        task_name: MaaStringView,
        out_task_result: MaaStringBufferHandle,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaCreateStringBuffer() -> MaaStringBufferHandle;
}
extern "C" {
    pub fn MaaDestroyStringBuffer(handle: MaaStringBufferHandle);
}
extern "C" {
    pub fn MaaIsStringEmpty(handle: MaaStringBufferHandle) -> MaaBool;
}
extern "C" {
    pub fn MaaClearString(handle: MaaStringBufferHandle) -> MaaBool;
}
extern "C" {
    pub fn MaaGetString(handle: MaaStringBufferHandle) -> MaaStringView;
}
extern "C" {
    pub fn MaaGetStringSize(handle: MaaStringBufferHandle) -> MaaSize;
}
extern "C" {
    pub fn MaaSetString(handle: MaaStringBufferHandle, str_: MaaStringView) -> MaaBool;
}
extern "C" {
    pub fn MaaSetStringEx(
        handle: MaaStringBufferHandle,
        str_: MaaStringView,
        size: MaaSize,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaCreateImageBuffer() -> MaaImageBufferHandle;
}
extern "C" {
    pub fn MaaDestroyImageBuffer(handle: MaaImageBufferHandle);
}
extern "C" {
    pub fn MaaIsImageEmpty(handle: MaaImageBufferHandle) -> MaaBool;
}
extern "C" {
    pub fn MaaClearImage(handle: MaaImageBufferHandle) -> MaaBool;
}
pub type MaaImageRawData = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn MaaGetImageRawData(handle: MaaImageBufferHandle) -> MaaImageRawData;
}
extern "C" {
    pub fn MaaGetImageWidth(handle: MaaImageBufferHandle) -> i32;
}
extern "C" {
    pub fn MaaGetImageHeight(handle: MaaImageBufferHandle) -> i32;
}
extern "C" {
    pub fn MaaGetImageType(handle: MaaImageBufferHandle) -> i32;
}
extern "C" {
    pub fn MaaSetImageRawData(
        handle: MaaImageBufferHandle,
        data: MaaImageRawData,
        width: i32,
        height: i32,
        type_: i32,
    ) -> MaaBool;
}
pub type MaaImageEncodedData = *mut u8;
extern "C" {
    pub fn MaaGetImageEncoded(handle: MaaImageBufferHandle) -> MaaImageEncodedData;
}
extern "C" {
    pub fn MaaGetImageEncodedSize(handle: MaaImageBufferHandle) -> MaaSize;
}
extern "C" {
    pub fn MaaSetImageEncoded(
        handle: MaaImageBufferHandle,
        data: MaaImageEncodedData,
        size: MaaSize,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaCreateRectBuffer() -> MaaRectHandle;
}
extern "C" {
    pub fn MaaDestroyRectBuffer(handle: MaaRectHandle);
}
extern "C" {
    pub fn MaaGetRectX(handle: MaaRectHandle) -> i32;
}
extern "C" {
    pub fn MaaGetRectY(handle: MaaRectHandle) -> i32;
}
extern "C" {
    pub fn MaaGetRectW(handle: MaaRectHandle) -> i32;
}
extern "C" {
    pub fn MaaGetRectH(handle: MaaRectHandle) -> i32;
}
extern "C" {
    pub fn MaaSetRect(handle: MaaRectHandle, x: i32, y: i32, w: i32, h: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSetRectX(handle: MaaRectHandle, value: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSetRectY(handle: MaaRectHandle, value: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSetRectW(handle: MaaRectHandle, value: i32) -> MaaBool;
}
extern "C" {
    pub fn MaaSetRectH(handle: MaaRectHandle, value: i32) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Get the version of the framework.\n\n @return MaaStringView"]
    pub fn MaaVersion() -> MaaStringView;
}
extern "C" {
    #[doc = " @brief Set options globally.\n\n This function requires a given set of option keys and value types, otherwise this will fail.\n See #MaaGlobalOptionEnum for details.\n\n @param key The option key.\n @param value The option value.\n @param val_size The size of the option value.\n @return MaaBool Whether the option is set successfully."]
    pub fn MaaSetGlobalOption(
        key: MaaGlobalOption,
        value: MaaOptionValue,
        val_size: MaaOptionValueSize,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaToolkitInitOptionConfig(
        user_path: MaaStringView,
        default_json: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " \\deprecated Use MaaToolkitInitOptionConfig instead."]
    pub fn MaaToolkitInit() -> MaaBool;
}
extern "C" {
    #[doc = " \\deprecated Don't use it."]
    pub fn MaaToolkitUninit() -> MaaBool;
}
extern "C" {
    #[doc = " \\deprecated Use MaaToolkitPostFindDevice() and MaaToolkitWaitForFindDeviceToComplete() instead."]
    pub fn MaaToolkitFindDevice() -> MaaSize;
}
extern "C" {
    #[doc = " \\deprecated Use MaaToolkitPostFindDeviceWithAdb() and MaaToolkitWaitForFindDeviceToComplete() instead."]
    pub fn MaaToolkitFindDeviceWithAdb(adb_path: MaaStringView) -> MaaSize;
}
extern "C" {
    #[doc = " @brief Post a request to find all ADB devices.\n\n @return MaaBool"]
    pub fn MaaToolkitPostFindDevice() -> MaaBool;
}
extern "C" {
    #[doc = " @brief Post a request to find all ADB devices with a given ADB path.\n\n @param adb_path\n @return MaaBool"]
    pub fn MaaToolkitPostFindDeviceWithAdb(adb_path: MaaStringView) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Check if the find device request is completed.\n\n @return MaaBool"]
    pub fn MaaToolkitIsFindDeviceCompleted() -> MaaBool;
}
extern "C" {
    #[doc = " @brief Wait for the find device request to complete.\n\n @return MaaSize The number of devices found."]
    pub fn MaaToolkitWaitForFindDeviceToComplete() -> MaaSize;
}
extern "C" {
    #[doc = " @brief Get the number of devices found.\n\n @return MaaSize The number of devices found."]
    pub fn MaaToolkitGetDeviceCount() -> MaaSize;
}
extern "C" {
    #[doc = " @brief Get the device name by index.\n\n @param index The 0-based index of the device. The index should not exceed the number of\n devices found otherwise out_of_range exception will be thrown.\n @return MaaStringView"]
    pub fn MaaToolkitGetDeviceName(index: MaaSize) -> MaaStringView;
}
extern "C" {
    #[doc = " @brief Get the device ADB path by index.\n\n @param index The 0-based index of the device. The index should not exceed the number of\n devices found otherwise out_of_range exception will be thrown.\n @return MaaStringView"]
    pub fn MaaToolkitGetDeviceAdbPath(index: MaaSize) -> MaaStringView;
}
extern "C" {
    #[doc = " @brief Get the device ADB serial by index.\n\n @param index The 0-based index of the device. The index should not exceed the number of\n devices found otherwise out_of_range exception will be thrown.\n @return MaaStringView"]
    pub fn MaaToolkitGetDeviceAdbSerial(index: MaaSize) -> MaaStringView;
}
extern "C" {
    #[doc = " @brief Get the device ADB controller type by index.\n\n @param index The 0-based index of the device. The index should not exceed the number of\n devices found otherwise out_of_range exception will be thrown.\n @return MaaAdbControllerType"]
    pub fn MaaToolkitGetDeviceAdbControllerType(index: MaaSize) -> MaaAdbControllerType;
}
extern "C" {
    #[doc = " @brief Get the device ADB config by index.\n\n @param index The 0-based index of the device. The index should not exceed the number of\n devices found otherwise out_of_range exception will be thrown.\n @return MaaStringView"]
    pub fn MaaToolkitGetDeviceAdbConfig(index: MaaSize) -> MaaStringView;
}
extern "C" {
    pub fn MaaToolkitRegisterCustomRecognizerExecutor(
        handle: MaaInstanceHandle,
        recognizer_name: MaaStringView,
        recognizer_exec_path: MaaStringView,
        recognizer_exec_param_json: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaToolkitUnregisterCustomRecognizerExecutor(
        handle: MaaInstanceHandle,
        recognizer_name: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaToolkitRegisterCustomActionExecutor(
        handle: MaaInstanceHandle,
        action_name: MaaStringView,
        action_exec_path: MaaStringView,
        action_exec_param_json: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    pub fn MaaToolkitUnregisterCustomActionExecutor(
        handle: MaaInstanceHandle,
        action_name: MaaStringView,
    ) -> MaaBool;
}
extern "C" {
    #[doc = " @brief Find a win32 window by class name and window name.\n\n This function finds the function by exact match. See also MaaToolkitSearchWindow().\n\n @param class_name The class name of the window. If passed an empty string, class name will\n not be filtered.\n @param window_name The window name of the window. If passed an empty string, window name will\n not be filtered.\n @return MaaSize The number of windows found that match the criteria. To get the corresponding\n window handle, use MaaToolkitGetWindow()."]
    pub fn MaaToolkitFindWindow(class_name: MaaStringView, window_name: MaaStringView) -> MaaSize;
}
extern "C" {
    #[doc = " @brief Search a win32 window by class name and window name.\n\n This function searches the function by substring match. See also MaaToolkitFindWindow().\n\n @param class_name The class name of the window. If passed an empty string, class name will\n not be filtered.\n @param window_name The window name of the window. If passed an empty string, window name will\n not be filtered.\n @return MaaSize The number of windows found that match the criteria. To get the corresponding\n window handle, use MaaToolkitGetWindow()."]
    pub fn MaaToolkitSearchWindow(class_name: MaaStringView, window_name: MaaStringView)
        -> MaaSize;
}
extern "C" {
    #[doc = " @brief Get the window handle by index.\n\n @param index The 0-based index of the window. The index should not exceed the number of\n windows found otherwise out_of_range exception will be thrown.\n @return MaaWin32Hwnd The window handle."]
    pub fn MaaToolkitGetWindow(index: MaaSize) -> MaaWin32Hwnd;
}
extern "C" {
    #[doc = " @brief Get the window handle of the window under the cursor. This uses the WindowFromPoint()\n system API.\n\n @return MaaWin32Hwnd The window handle."]
    pub fn MaaToolkitGetCursorWindow() -> MaaWin32Hwnd;
}
extern "C" {
    #[doc = " @brief Get the desktop window handle. This uses the GetDesktopWindow() system API.\n\n @return MaaWin32Hwnd The window handle."]
    pub fn MaaToolkitGetDesktopWindow() -> MaaWin32Hwnd;
}
extern "C" {
    #[doc = " @brief Get the foreground window handle. This uses the GetForegroundWindow() system API.\n\n @return MaaWin32Hwnd The window handle."]
    pub fn MaaToolkitGetForegroundWindow() -> MaaWin32Hwnd;
}
